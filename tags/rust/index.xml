<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Rust - Tag - Jorge Ortiz-Fuentes&#39; DevBites</title>
        <link>https://jorgeortiz.dev/tags/rust/</link>
        <description>Rust - Tag - Jorge Ortiz-Fuentes&#39; DevBites</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2025 Jorge D. Ortiz Fuentes</copyright><lastBuildDate>Mon, 20 Oct 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jorgeortiz.dev/tags/rust/" rel="self" type="application/rss+xml" /><item>
    <title>Rust unit testing: spy and dummy test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</link>
    <pubDate>Mon, 20 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I explained what test doubles are and why we need them.  In this one, I am going to focus on two
different types of test doubles: <strong>the spy</strong> and <strong>the dummy</strong>.<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup></p>
<p>
A spy is a test double that remembers if its methods have been invoked and the arguments used with each invocation.  It
<em>spies</em> on the activity of the caller instance.  A dummy does nothing, but it is required to create or use something
else.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: test doubles &amp; stubs</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_stub/</link>
    <pubDate>Tue, 07 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_stub/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
Unit testing is about writing tests for individual units (Duh!), most frequently these units are the types that we
define in our code, i.e., structs / enums / unions, or first-class functions.  But the types that we want to test
usually have dependencies on other types and we would like to test them in isolation without having to worry about the
details of those dependencies.  That&#39;s why you need test doubles.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: add-ons</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_tools_add_ons/</link>
    <pubDate>Mon, 29 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_tools_add_ons/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I wrote about some builtin features of the tools that come with our Rust setup.  They help you to
produce better documentation, have more control of the tests you run, and debug tests/code when needed.  The Rust
ecosystem is very rich and active and people with other needs have contributed with really useful tools.</p>
<p>
Today, I will write about two tools that might come in handy for you sooner or latter.  There are many details in the
following paragraphs, so fasten your USB-C cable and get ready!</p>]]></description>
</item>
<item>
    <title>Rust unit testing: builtin tools</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_tools_builtin/</link>
    <pubDate>Mon, 22 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_tools_builtin/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
As many other modern languages, regarding testing, Rust comes with batteries included.  As you have seen in the previous
articles of this series, you don&#39;t need to take any extra steps to be able to write and run unit tests for your code.
It is clear where you have to put them, how to run them, and even cargo has a subcommand for finding and running
them, and reporting the results.  Could we ask for more?</p>]]></description>
</item>
<item>
    <title>Full-Stack Apps</title>
    <link>https://jorgeortiz.dev/posts/full_stack_apps/</link>
    <pubDate>Tue, 16 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_apps/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
I must confess.  For many years, I have tried to avoid front-end web development by all means.  I didn&#39;t want to touch
it with a ten foot pole.  And the main reason was because I have never felt comfortable with having to combine HTML, CSS
and JavaScript with the nuances of each of the browsers to get the UI I wanted to produce.</p>
<p>
When it came to develop user interfaces for my applications, I have preferred to use well established APIs.  I started,
looong ago, writing some small Windows applications, moved to X Window first and then to GTK, and after a while focused
on mobile development.  Even at that stage, I jumped from PalmOS to Android and iOS, almost skipping webOS<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup> because
of it being based on web development.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: asynchronous code</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_async_code/</link>
    <pubDate>Wed, 10 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_async_code/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So far, we have only tested synchronous code.  I could postpone talking about asynchronous code, but I don&#39;t want you to
<em>wait</em> for it. ðŸ˜„</p>
<p>
Asynchronous code, apart from being an inexhaustible source of dad jokes, can be painful to reason about its behavior
and <a href="https://corrode.dev/blog/async/">not always recommended</a>.  We tend to think that, in a given scope, the lines above are executed before the lines
below.  It really takes experience and discipline to realize that some parts of the code can be executed at a later time
and that we may not have yet their results available.  This is important when we write our asynchronous code, but even
more when we debug it .</p>]]></description>
</item>
<item>
    <title>Rust unit testing: the not so happy path</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_not_so_happy_path/</link>
    <pubDate>Mon, 01 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_not_so_happy_path/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So far, we have chosen to test things that matched our expectations of how the code was supposed to work and how the
user and the environment were supposed to behave.  But, we should also plan for the scenarios in which things don&#39;t go as
expected, and still we want our program to react properly.  We should also test for these situations and those tests are
as important as the ones that check the successful use cases.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: simplify your tests</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_simplify_tests/</link>
    <pubDate>Thu, 10 Jul 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_simplify_tests/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
Now that we understand the building blocks for writing unit tests in Rust, you probably feel the urge to apply that
knowledge and fully cover your application with tests.  Don&#39;t you?  Well, I would ask you to hold your horses and apply
it gradually. We still have a lot of ground to cover, but the next sections are probably going to simplify your life
right away.</p>
<p>
Again in this article, you have the final version of the <code class="verbatim">supervillain.rs</code> file at the bottom and the repo with the
incremental commits is available <a href="https://github.com/jdortiz/detestable-me-rs">here</a>.  In case of doubt, check the code or feel free to reach me through any of my
<a href="https://jorgeortiz.dev/">social media accounts</a>.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: test types</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_types/</link>
    <pubDate>Mon, 07 Jul 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_types/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So you have finally learned Rust and are writing cool projects with it?  Awesome!  However, as soon as your project
starts being useful and solving some actual use cases, you realize that the quality of your code is important.  Not only
that.  The larger and more complex your project becomes, the harder it is to manually test every bit of functionality
after a change.</p>
<p>
Your first temptation might be: &#34;Why should I test everything if my changes only affect this small part of the program?&#34;
And, while in some situations that might be true, more often than not our changes affect unexpected parts of our
program.</p>]]></description>
</item>
</channel>
</rss>
