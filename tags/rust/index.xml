<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Rust - Tag - Jorge Ortiz-Fuentes&#39; DevBites</title>
        <link>https://jorgeortiz.dev/tags/rust/</link>
        <description>Rust - Tag - Jorge Ortiz-Fuentes&#39; DevBites</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2025 Jorge D. Ortiz Fuentes</copyright><lastBuildDate>Tue, 27 Jan 2026 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jorgeortiz.dev/tags/rust/" rel="self" type="application/rss+xml" /><item>
    <title>Using Oracle db26ai from Rust with the sibyl crate (2)</title>
    <link>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_sibyl_crate_2/</link>
    <pubDate>Tue, 27 Jan 2026 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_sibyl_crate_2/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><blockquote>
<p>WARNING:</p>
<p>
This article closely mirrors the one about <a href="/posts/rust_use_oracle_db26ai_with_oracle_crate_1/">Using Oracle from Rust with <code class="verbatim">oracle</code></a>, as both are designed to be
self-contained.  You can read them either independently, sequentially, or use them to compare what they can offer to
you.</p>
</blockquote>
<p>
In this article, I will use the <a href="https://crates.io/crates/sibyl">sibyl</a> crate to modify data, create and drop new tables and indexes, and perform a vector
search from Rust code.  I have <a href="/posts/rust_use_oracle_db26ai_with_sibyl_crate_1/">already explained how to use it to make queries in different ways</a> and how to easily set
up an environment to work with it.  If you want to read that first, I will wait for you here.</p>]]></description>
</item>
<item>
    <title>Using Oracle db26ai from Rust with the oracle crate (2)</title>
    <link>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_oracle_crate_2/</link>
    <pubDate>Fri, 23 Jan 2026 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_oracle_crate_2/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><blockquote>
<p>WARNING:</p>
<p>
This article closely mirrors the one about <a href="/posts/rust_use_oracle_db26ai_with_sibyl_crate_1/">Using Oracle from Rust with <code class="verbatim">sibyl</code></a>, as both are designed to be
self-contained.  You can read them either independently, sequentially, or use them to compare what they can offer to
you.</p>
</blockquote>
<p>
In this article, I will use the <a href="https://crates.io/crates/oracle">oracle</a> crate to modify data, create and drop new tables and indexes, and perform a vector
search from Rust code.  I have <a href="/posts/rust_use_oracle_db26ai_with_oracle_crate_1/">already explained how to use it to make queries in different ways</a> and how to
easily set up an environment to work with it.  If you want to read that first, I will wait for you here.</p>]]></description>
</item>
<item>
    <title>Using Oracle db26ai from Rust with the sibyl crate</title>
    <link>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_sibyl_crate_1/</link>
    <pubDate>Wed, 21 Jan 2026 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_sibyl_crate_1/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><blockquote>
<p>WARNING:</p>
<p>
This article shares many parts and its structure with the one about <a href="/posts/rust_use_oracle_db26ai_with_oracle_crate_1/">Using Oracle from Rust with <code class="verbatim">oracle</code></a>, because I
wanted both to be self-contained.  You can read them independently, one after the other or use them to compare what they
can offer to you.</p>
<p>
If you have already set up your database instance using the other article, you are good to go.  Jump straight to the
&#34;First &#39;contact&#39; with the Oracle DB instance&#34; section.</p>]]></description>
</item>
<item>
    <title>Using Oracle db26ai from Rust with the oracle crate</title>
    <link>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_oracle_crate_1/</link>
    <pubDate>Fri, 16 Jan 2026 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_use_oracle_db26ai_with_oracle_crate_1/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><blockquote>
<p>WARNING:</p>
<p>
This article shares many parts and its structure with the one about <a href="/posts/rust_use_oracle_db26ai_with_sibyl_crate_1/">Using Oracle from Rust with <code class="verbatim">sibyl</code></a>, because I
wanted both to be self-contained.  You can read them independently, one after the other or use them to compare what
they can offer to you.</p>
<p>
If you have already set up your database instance using the other article, you are good to go.  Jump straight to the
&#34;First &#39;contact&#39; with the Oracle DB instance&#34; section.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: basic HTTP testing</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_basic_http_srvr/</link>
    <pubDate>Thu, 18 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_basic_http_srvr/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In previous articles in this series, I have highlighted the importance of unit testing your code.  However, I
must reckon that most of the examples I have used were mostly isolated.  There weren&#39;t many connections between one
scenario and the next, and, admittedly, not a single application that integrated all the scenarios as a whole.</p>
<p>
I hope this has fulfilled the purpose of sharing knowledge about unit testing in Rust.  But one of the first challenges
I had to overcome once I had learned the very basics of writing automated tests was integrating them into a real
codebase.  But it is hard to walk this path alone, since the first (real) tests are also the hardest.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: file writing</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_writing/</link>
    <pubDate>Thu, 11 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_writing/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
This is the third and last article on file I/O testing, and yet again, the focus is on the technique for injecting a
dependency so we can use it in the tests.  In this article, I will cover a writing scenario that requires us to access the
test double after invoking our code to check the written contents.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Writing to a file
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>If you are just a regular villain, your henchmen are close to you.  You have recruited them personally, know what they
can do, and call each one of them by their name…  Well, not really, because you don&#39;t care about their names.  But you
don&#39;t have any issues letting them know what you want from them, because they are always around you.  Those times are
long gone and deeply missed.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: buffered file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</link>
    <pubDate>Tue, 09 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the previous article, I explained how to use a test double to replace a <code>File</code> instance and control the behavior
required by a function that reads from it.  With the test double in place, I was able not only to return what I needed
for the scenarios where I needed reading, but also to produce errors that allowed me <a href="/posts/rust_unit_testing_not_so_happy_path/">to test the not-so-happy path</a>.</p>
<p>
I got some concerned comments pointing out that the test code wasn&#39;t reading, which was an essential part of what we
were testing.  I agree that the test code isn&#39;t actually reading.  It isn&#39;t, and that is on purpose.  On the one hand,
reading isn&#39;t an essential part of what we are testing.  On the contrary, <code>File</code> is a dependency of the
<code>are_there_vulnerable_locations()</code> method, and, as with any other dependency, it can be replaced by a test double.  The
code isn&#39;t making it easy to inject the dependency, because the <code>File</code> instance is created inside of the method –and as
you may already know, every time you create an instance inside of your code, a kitten is killed<sup class="footnote-reference"><a id="footnote-reference-2" href="#footnote-2">2</a></sup>.  But I applied
what I had already explained to replace dependencies using the namespace.  On the other hand, we gain additional
benefits by using a test double.  I mentioned that performance is much better, but you can only notice the difference
with a large test suite.  However, it is also important that the test double can easily reproduce <code>File</code> behaviors that
would require some work when you are actually interacting with the filesystem.  For example, opening the file for
reading successfully and then failing to read from it right away.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</link>
    <pubDate>Mon, 24 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So far, I have covered several scenarios. Yet all the interactions in those scenarios occurred in memory: one instance
of a type talking to another instance of another type. However, in the real world, our applications do more than just
invoke functions or methods, and we would like to test those use cases.</p>
<p>
One of the most common things that applications do and that deserves testing is reading from and writing to files.
Files are among the most frequently used input and output mechanisms in many applications, and it is key that they behave
as expected when using files.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mocking library</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</link>
    <pubDate>Mon, 17 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In earlier articles about test doubles, I showed how to create them without using any libraries.  While I believe that
is the best way to understand how they work, how they can help, and how to use them, it is far from being a convenient
way of writing your tests.</p>
<p>
In this article, I will explain how to use a mocking library and replace all the test doubles we wrote with others that
are produced by the library.  Prepare for a more streamlined version of the code that achieves the same goals with less
effort!</p>]]></description>
</item>
<item>
    <title>Rust unit testing: assertion libraries</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</link>
    <pubDate>Fri, 14 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
At the beginning of this series, I explained how to write a test by decomposing it into three parts: arrange, act, and
assert.  Since then, we have written several unit tests using that structure.  Most of the assertions we&#39;ve written in
those tests used the <code>assert_eq!()</code> macro.  Sometimes, they were a very obvious way to state what was expected and the
actual value that was produced.  It’s clear and works well for simple checks. However, in other cases, the syntax is
awkward or doesn&#39;t clearly convey what we mean, requiring extra steps or missing necessary functionality.</p>]]></description>
</item>
</channel>
</rss>
