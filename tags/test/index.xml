<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Test - Tag - Jorge Ortiz-Fuentes&#39; DevBites</title>
        <link>https://jorgeortiz.dev/tags/test/</link>
        <description>Test - Tag - Jorge Ortiz-Fuentes&#39; DevBites</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2025 Jorge D. Ortiz Fuentes</copyright><lastBuildDate>Thu, 11 Dec 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jorgeortiz.dev/tags/test/" rel="self" type="application/rss+xml" /><item>
    <title>Rust unit testing: file writing</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_writing/</link>
    <pubDate>Thu, 11 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_writing/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
This is the third and last article on file I/O testing, and yet again, the focus is on the technique for injecting a
dependency so we can use it in the tests.  In this article, I will cover a writing scenario that requires us to access the
test double after invoking our code to check the written contents.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Writing to a file
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>If you are just a regular villain, your henchmen are close to you.  You have recruited them personally, know what they
can do, and call each one of them by their name…  Well, not really, because you don&#39;t care about their names.  But you
don&#39;t have any issues letting them know what you want from them, because they are always around you.  Those times are
long gone and deeply missed.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: buffered file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</link>
    <pubDate>Tue, 09 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the previous article, I explained how to use a test double to replace a <code>File</code> instance and control the behavior
required by a function that reads from it.  With the test double in place, I was able not only to return what I needed
for the scenarios where I needed reading, but also to produce errors that allowed me <a href="/posts/rust_unit_testing_not_so_happy_path/">to test the not-so-happy path</a>.</p>
<p>
I got some concerned comments pointing out that the test code wasn&#39;t reading, which was an essential part of what we
were testing.  I agree that the test code isn&#39;t actually reading.  It isn&#39;t, and that is on purpose.  On the one hand,
reading isn&#39;t an essential part of what we are testing.  On the contrary, <code>File</code> is a dependency of the
<code>are_there_vulnerable_locations()</code> method, and, as with any other dependency, it can be replaced by a test double.  The
code isn&#39;t making it easy to inject the dependency, because the <code>File</code> instance is created inside of the method –and as
you may already know, every time you create an instance inside of your code, a kitten is killed<sup class="footnote-reference"><a id="footnote-reference-2" href="#footnote-2">2</a></sup>.  But I applied
what I had already explained to replace dependencies using the namespace.  On the other hand, we gain additional
benefits by using a test double.  I mentioned that performance is much better, but you can only notice the difference
with a large test suite.  However, it is also important that the test double can easily reproduce <code>File</code> behaviors that
would require some work when you are actually interacting with the filesystem.  For example, opening the file for
reading successfully and then failing to read from it right away.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</link>
    <pubDate>Mon, 24 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So far, I have covered several scenarios. Yet all the interactions in those scenarios occurred in memory: one instance
of a type talking to another instance of another type. However, in the real world, our applications do more than just
invoke functions or methods, and we would like to test those use cases.</p>
<p>
One of the most common things that applications do and that deserves testing is reading from and writing to files.
Files are among the most frequently used input and output mechanisms in many applications, and it is key that they behave
as expected when using files.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mocking library</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</link>
    <pubDate>Mon, 17 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In earlier articles about test doubles, I showed how to create them without using any libraries.  While I believe that
is the best way to understand how they work, how they can help, and how to use them, it is far from being a convenient
way of writing your tests.</p>
<p>
In this article, I will explain how to use a mocking library and replace all the test doubles we wrote with others that
are produced by the library.  Prepare for a more streamlined version of the code that achieves the same goals with less
effort!</p>]]></description>
</item>
<item>
    <title>Rust unit testing: assertion libraries</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</link>
    <pubDate>Fri, 14 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
At the beginning of this series, I explained how to write a test by decomposing it into three parts: arrange, act, and
assert.  Since then, we have written several unit tests using that structure.  Most of the assertions we&#39;ve written in
those tests used the <code>assert_eq!()</code> macro.  Sometimes, they were a very obvious way to state what was expected and the
actual value that was produced.  It’s clear and works well for simple checks. However, in other cases, the syntax is
awkward or doesn&#39;t clearly convey what we mean, requiring extra steps or missing necessary functionality.</p>]]></description>
</item>
<item>
    <title>Rust unit testing test doubles: fakes</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</link>
    <pubDate>Mon, 03 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my previous articles, I have been writing about test doubles.  I explained what they are and the different types we
can use.  I described some scenarios and wrote the test doubles that would help us test the code: dummies, stubs, spies,
and mocks.  Only one type was left: fakes.  Let&#39;s look at those now.</p>
<p>
Fakes are tests doubles that implement a simplified version of a task or computation.  They come in handy when the real thing is
slow or complicated.  Ciphering messages is usually an expensive task, and we don&#39;t want our tests to take longer than they
should.  So, instead of performing the (real) encryption, we will have a fake that makes a simpler text manipulation.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mock test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_mock/</link>
    <pubDate>Mon, 27 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_mock/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
This is the third article on test doubles.  So far, I have covered stubs –that are used to control the responses to
the methods of the type they double,– dummies –that fill &#34;holes&#34; that are required for some tests without any
functionality,– and spies –that remember the interactions with the type they double.  It is time to talk about the
<em>face of the band</em>: mocks.</p>
<p>
For the price of a mock, you get everything that was included in a stub and a spy, plus some intelligence.  And I am not
talking about AI.  Mocks are a little smarter than stubs and spies, because they include the code to verify themselves.
All those ugly asserts that used the fields in the guts of the spies will be no longer necessary.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: spy and dummy test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</link>
    <pubDate>Mon, 20 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I explained what test doubles are and why we need them.  In this one, I am going to focus on two
different types of test doubles: <strong>the spy</strong> and <strong>the dummy</strong>.<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup></p>
<p>
A spy is a test double that remembers if its methods have been invoked and the arguments used with each invocation.  It
<em>spies</em> on the activity of the caller instance.  A dummy does nothing, but it is required to create or use something
else.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: test doubles &amp; stubs</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_stub/</link>
    <pubDate>Tue, 07 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_stub/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
Unit testing is about writing tests for individual units (Duh!), most frequently these units are the types that we
define in our code, i.e., structs / enums / unions, or first-class functions.  But the types that we want to test
usually have dependencies on other types and we would like to test them in isolation without having to worry about the
details of those dependencies.  That&#39;s why you need test doubles.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: add-ons</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_tools_add_ons/</link>
    <pubDate>Mon, 29 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_tools_add_ons/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I wrote about some builtin features of the tools that come with our Rust setup.  They help you to
produce better documentation, have more control of the tests you run, and debug tests/code when needed.  The Rust
ecosystem is very rich and active and people with other needs have contributed with really useful tools.</p>
<p>
Today, I will write about two tools that might come in handy for you sooner or latter.  There are many details in the
following paragraphs, so fasten your USB-C cable and get ready!</p>]]></description>
</item>
</channel>
</rss>
