<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tutorial - Category - Jorge Ortiz-Fuentes&#39; DevBites</title>
        <link>https://jorgeortiz.dev/categories/tutorial/</link>
        <description>Tutorial - Category - Jorge Ortiz-Fuentes&#39; DevBites</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2025 Jorge D. Ortiz Fuentes</copyright><lastBuildDate>Tue, 09 Dec 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jorgeortiz.dev/categories/tutorial/" rel="self" type="application/rss+xml" /><item>
    <title>Rust unit testing: buffered file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</link>
    <pubDate>Tue, 09 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the previous article, I explained how to use a test double to replace a <code>File</code> instance and control the behavior
required by a function that reads from it.  With the test double in place, I was able not only to return what I needed
for the scenarios where I needed reading, but also to produce errors that allowed me <a href="/posts/rust_unit_testing_not_so_happy_path/">to test the not-so-happy path</a>.</p>
<p>
I got some concerned comments pointing out that the test code wasn&#39;t reading, which was an essential part of what we
were testing.  I agree that the test code isn&#39;t actually reading.  It isn&#39;t, and that is on purpose.  On the one hand,
reading isn&#39;t an essential part of what we are testing.  On the contrary, <code>File</code> is a dependency of the
<code>are_there_vulnerable_locations()</code> method, and, as with any other dependency, it can be replaced by a test double.  The
code isn&#39;t making it easy to inject the dependency, because the <code>File</code> instance is created inside of the method –and as
you may already know, every time you create an instance inside of your code, a kitten is killed<sup class="footnote-reference"><a id="footnote-reference-2" href="#footnote-2">2</a></sup>.  But I applied
what I had already explained to replace dependencies using the namespace.  On the other hand, we gain additional
benefits by using a test double.  I mentioned that performance is much better, but you can only notice the difference
with a large test suite.  However, it is also important that the test double can easily reproduce <code>File</code> behaviors that
would require some work when you are actually interacting with the filesystem.  For example, opening the file for
reading successfully and then failing to read from it right away.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</link>
    <pubDate>Mon, 24 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So far, I have covered several scenarios. Yet all the interactions in those scenarios occurred in memory: one instance
of a type talking to another instance of another type. However, in the real world, our applications do more than just
invoke functions or methods, and we would like to test those use cases.</p>
<p>
One of the most common things that applications do and that deserves testing is reading from and writing to files.
Files are among the most frequently used input and output mechanisms in many applications, and it is key that they behave
as expected when using files.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mocking library</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</link>
    <pubDate>Mon, 17 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In earlier articles about test doubles, I showed how to create them without using any libraries.  While I believe that
is the best way to understand how they work, how they can help, and how to use them, it is far from being a convenient
way of writing your tests.</p>
<p>
In this article, I will explain how to use a mocking library and replace all the test doubles we wrote with others that
are produced by the library.  Prepare for a more streamlined version of the code that achieves the same goals with less
effort!</p>]]></description>
</item>
<item>
    <title>Rust unit testing: assertion libraries</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</link>
    <pubDate>Fri, 14 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
At the beginning of this series, I explained how to write a test by decomposing it into three parts: arrange, act, and
assert.  Since then, we have written several unit tests using that structure.  Most of the assertions we&#39;ve written in
those tests used the <code>assert_eq!()</code> macro.  Sometimes, they were a very obvious way to state what was expected and the
actual value that was produced.  It’s clear and works well for simple checks. However, in other cases, the syntax is
awkward or doesn&#39;t clearly convey what we mean, requiring extra steps or missing necessary functionality.</p>]]></description>
</item>
<item>
    <title>Full-stack application in Go: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_go_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_go_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Go.  I will cover project creation and structure, and build
automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a good and
helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Full-stack application in Java: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_java_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_java_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.png" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Java + Spring.  I will cover project creation and structure,
and build automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a
good and helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Full-stack application in Rust: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_rust_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_rust_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Rust.  I will cover project creation and structure, as well as build
automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a good and
helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Rust unit testing test doubles: fakes</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</link>
    <pubDate>Mon, 03 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my previous articles, I have been writing about test doubles.  I explained what they are and the different types we
can use.  I described some scenarios and wrote the test doubles that would help us test the code: dummies, stubs, spies,
and mocks.  Only one type was left: fakes.  Let&#39;s look at those now.</p>
<p>
Fakes are tests doubles that implement a simplified version of a task or computation.  They come in handy when the real thing is
slow or complicated.  Ciphering messages is usually an expensive task, and we don&#39;t want our tests to take longer than they
should.  So, instead of performing the (real) encryption, we will have a fake that makes a simpler text manipulation.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mock test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_mock/</link>
    <pubDate>Mon, 27 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_mock/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
This is the third article on test doubles.  So far, I have covered stubs –that are used to control the responses to
the methods of the type they double,– dummies –that fill &#34;holes&#34; that are required for some tests without any
functionality,– and spies –that remember the interactions with the type they double.  It is time to talk about the
<em>face of the band</em>: mocks.</p>
<p>
For the price of a mock, you get everything that was included in a stub and a spy, plus some intelligence.  And I am not
talking about AI.  Mocks are a little smarter than stubs and spies, because they include the code to verify themselves.
All those ugly asserts that used the fields in the guts of the spies will be no longer necessary.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: spy and dummy test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</link>
    <pubDate>Mon, 20 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I explained what test doubles are and why we need them.  In this one, I am going to focus on two
different types of test doubles: <strong>the spy</strong> and <strong>the dummy</strong>.<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup></p>
<p>
A spy is a test double that remembers if its methods have been invoked and the arguments used with each invocation.  It
<em>spies</em> on the activity of the caller instance.  A dummy does nothing, but it is required to create or use something
else.</p>]]></description>
</item>
</channel>
</rss>
