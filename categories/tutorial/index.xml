<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tutorial - Category - Jorge Ortiz-Fuentes&#39; DevBites</title>
        <link>https://jorgeortiz.dev/categories/tutorial/</link>
        <description>Tutorial - Category - Jorge Ortiz-Fuentes&#39; DevBites</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2025 Jorge D. Ortiz Fuentes</copyright><lastBuildDate>Thu, 18 Dec 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jorgeortiz.dev/categories/tutorial/" rel="self" type="application/rss+xml" /><item>
    <title>Rust unit testing: basic HTTP testing</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_basic_http_srvr/</link>
    <pubDate>Thu, 18 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_basic_http_srvr/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In previous articles in this series, I have highlighted the importance of unit testing your code.  However, I
must reckon that most of the examples I have used were mostly isolated.  There weren&#39;t many connections between one
scenario and the next, and, admittedly, not a single application that integrated all the scenarios as a whole.</p>
<p>
I hope this has fulfilled the purpose of sharing knowledge about unit testing in Rust.  But one of the first challenges
I had to overcome once I had learned the very basics of writing automated tests was integrating them into a real
codebase.  But it is hard to walk this path alone, since the first (real) tests are also the hardest.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: file writing</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_writing/</link>
    <pubDate>Thu, 11 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_writing/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
This is the third and last article on file I/O testing, and yet again, the focus is on the technique for injecting a
dependency so we can use it in the tests.  In this article, I will cover a writing scenario that requires us to access the
test double after invoking our code to check the written contents.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Writing to a file
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>If you are just a regular villain, your henchmen are close to you.  You have recruited them personally, know what they
can do, and call each one of them by their name…  Well, not really, because you don&#39;t care about their names.  But you
don&#39;t have any issues letting them know what you want from them, because they are always around you.  Those times are
long gone and deeply missed.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: buffered file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</link>
    <pubDate>Tue, 09 Dec 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_buf_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the previous article, I explained how to use a test double to replace a <code>File</code> instance and control the behavior
required by a function that reads from it.  With the test double in place, I was able not only to return what I needed
for the scenarios where I needed reading, but also to produce errors that allowed me <a href="/posts/rust_unit_testing_not_so_happy_path/">to test the not-so-happy path</a>.</p>
<p>
I got some concerned comments pointing out that the test code wasn&#39;t reading, which was an essential part of what we
were testing.  I agree that the test code isn&#39;t actually reading.  It isn&#39;t, and that is on purpose.  On the one hand,
reading isn&#39;t an essential part of what we are testing.  On the contrary, <code>File</code> is a dependency of the
<code>are_there_vulnerable_locations()</code> method, and, as with any other dependency, it can be replaced by a test double.  The
code isn&#39;t making it easy to inject the dependency, because the <code>File</code> instance is created inside of the method –and as
you may already know, every time you create an instance inside of your code, a kitten is killed<sup class="footnote-reference"><a id="footnote-reference-2" href="#footnote-2">2</a></sup>.  But I applied
what I had already explained to replace dependencies using the namespace.  On the other hand, we gain additional
benefits by using a test double.  I mentioned that performance is much better, but you can only notice the difference
with a large test suite.  However, it is also important that the test double can easily reproduce <code>File</code> behaviors that
would require some work when you are actually interacting with the filesystem.  For example, opening the file for
reading successfully and then failing to read from it right away.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: file reading</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</link>
    <pubDate>Mon, 24 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_file_reading/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
So far, I have covered several scenarios. Yet all the interactions in those scenarios occurred in memory: one instance
of a type talking to another instance of another type. However, in the real world, our applications do more than just
invoke functions or methods, and we would like to test those use cases.</p>
<p>
One of the most common things that applications do and that deserves testing is reading from and writing to files.
Files are among the most frequently used input and output mechanisms in many applications, and it is key that they behave
as expected when using files.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mocking library</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</link>
    <pubDate>Mon, 17 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_mocking_library/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In earlier articles about test doubles, I showed how to create them without using any libraries.  While I believe that
is the best way to understand how they work, how they can help, and how to use them, it is far from being a convenient
way of writing your tests.</p>
<p>
In this article, I will explain how to use a mocking library and replace all the test doubles we wrote with others that
are produced by the library.  Prepare for a more streamlined version of the code that achieves the same goals with less
effort!</p>]]></description>
</item>
<item>
    <title>Rust unit testing: assertion libraries</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</link>
    <pubDate>Fri, 14 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
At the beginning of this series, I explained how to write a test by decomposing it into three parts: arrange, act, and
assert.  Since then, we have written several unit tests using that structure.  Most of the assertions we&#39;ve written in
those tests used the <code>assert_eq!()</code> macro.  Sometimes, they were a very obvious way to state what was expected and the
actual value that was produced.  It’s clear and works well for simple checks. However, in other cases, the syntax is
awkward or doesn&#39;t clearly convey what we mean, requiring extra steps or missing necessary functionality.</p>]]></description>
</item>
<item>
    <title>Full-stack application in Go: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_go_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_go_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Go.  I will cover project creation and structure, and build
automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a good and
helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Full-stack application in Java: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_java_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_java_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.png" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Java + Spring.  I will cover project creation and structure,
and build automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a
good and helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Full-stack application in Rust: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_rust_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_rust_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Rust.  I will cover project creation and structure, as well as build
automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a good and
helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Rust unit testing test doubles: fakes</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</link>
    <pubDate>Mon, 03 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my previous articles, I have been writing about test doubles.  I explained what they are and the different types we
can use.  I described some scenarios and wrote the test doubles that would help us test the code: dummies, stubs, spies,
and mocks.  Only one type was left: fakes.  Let&#39;s look at those now.</p>
<p>
Fakes are tests doubles that implement a simplified version of a task or computation.  They come in handy when the real thing is
slow or complicated.  Ciphering messages is usually an expensive task, and we don&#39;t want our tests to take longer than they
should.  So, instead of performing the (real) encryption, we will have a fake that makes a simpler text manipulation.</p>]]></description>
</item>
</channel>
</rss>
