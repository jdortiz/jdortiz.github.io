<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tutorial - Category - Jorge Ortiz-Fuentes&#39; DevBites</title>
        <link>https://jorgeortiz.dev/categories/tutorial/</link>
        <description>Tutorial - Category - Jorge Ortiz-Fuentes&#39; DevBites</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&amp;copy; 2025 Jorge D. Ortiz Fuentes</copyright><lastBuildDate>Fri, 14 Nov 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jorgeortiz.dev/categories/tutorial/" rel="self" type="application/rss+xml" /><item>
    <title>Rust unit testing: assertion libraries</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</link>
    <pubDate>Fri, 14 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_assertion_libraries/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
At the beginning of this series, I explained how to write a test by decomposing it into three parts: arrange, act, and
assert.  Since then, we have written several unit tests using that structure.  Most of the assertions we&#39;ve written in
those tests used the <code>assert_eq!()</code> macro.  Sometimes, they were a very obvious way to state what was expected and the
actual value that was produced.  It’s clear and works well for simple checks. However, in other cases, the syntax is
awkward or doesn&#39;t clearly convey what we mean, requiring extra steps or missing necessary functionality.</p>]]></description>
</item>
<item>
    <title>Full-stack application in Go: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_go_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_go_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Go.  I will cover project creation and structure, and build
automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a good and
helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Full-stack application in Java: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_java_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_java_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.png" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Java + Spring.  I will cover project creation and structure,
and build automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a
good and helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Full-stack application in Rust: Quick start</title>
    <link>https://jorgeortiz.dev/posts/full_stack_rust_quick_start/</link>
    <pubDate>Tue, 11 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/full_stack_rust_quick_start/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In the article introducing this series, I shared that I wanted to explore full-stack app development.  In particular, I
wanted to develop a full-stack application that helps people manage their checklists.  Users will use a browser to
connect to the front-end server, which, in turn, will use the API provided by the back-end server to access and modify
the checklists.</p>
<p>
This article is the first one describing what I am doing in Rust.  I will cover project creation and structure, as well as build
automation.  We won&#39;t have much of the application implemented by the end of this article, but it should be a good and
helpful start. So buckle up and let&#39;s get cracking!</p>]]></description>
</item>
<item>
    <title>Rust unit testing test doubles: fakes</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</link>
    <pubDate>Mon, 03 Nov 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_fake/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my previous articles, I have been writing about test doubles.  I explained what they are and the different types we
can use.  I described some scenarios and wrote the test doubles that would help us test the code: dummies, stubs, spies,
and mocks.  Only one type was left: fakes.  Let&#39;s look at those now.</p>
<p>
Fakes are tests doubles that implement a simplified version of a task or computation.  They come in handy when the real thing is
slow or complicated.  Ciphering messages is usually an expensive task, and we don&#39;t want our tests to take longer than they
should.  So, instead of performing the (real) encryption, we will have a fake that makes a simpler text manipulation.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: mock test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_mock/</link>
    <pubDate>Mon, 27 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_mock/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
This is the third article on test doubles.  So far, I have covered stubs –that are used to control the responses to
the methods of the type they double,– dummies –that fill &#34;holes&#34; that are required for some tests without any
functionality,– and spies –that remember the interactions with the type they double.  It is time to talk about the
<em>face of the band</em>: mocks.</p>
<p>
For the price of a mock, you get everything that was included in a stub and a spy, plus some intelligence.  And I am not
talking about AI.  Mocks are a little smarter than stubs and spies, because they include the code to verify themselves.
All those ugly asserts that used the fields in the guts of the spies will be no longer necessary.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: spy and dummy test doubles</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</link>
    <pubDate>Mon, 20 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_spy/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I explained what test doubles are and why we need them.  In this one, I am going to focus on two
different types of test doubles: <strong>the spy</strong> and <strong>the dummy</strong>.<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup></p>
<p>
A spy is a test double that remembers if its methods have been invoked and the arguments used with each invocation.  It
<em>spies</em> on the activity of the caller instance.  A dummy does nothing, but it is required to create or use something
else.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: test doubles &amp; stubs</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_stub/</link>
    <pubDate>Tue, 07 Oct 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_test_doubles_stub/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
Unit testing is about writing tests for individual units (Duh!), most frequently these units are the types that we
define in our code, i.e., structs / enums / unions, or first-class functions.  But the types that we want to test
usually have dependencies on other types and we would like to test them in isolation without having to worry about the
details of those dependencies.  That&#39;s why you need test doubles.</p>]]></description>
</item>
<item>
    <title>Rust unit testing: add-ons</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_tools_add_ons/</link>
    <pubDate>Mon, 29 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_tools_add_ons/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
In my last article, I wrote about some builtin features of the tools that come with our Rust setup.  They help you to
produce better documentation, have more control of the tests you run, and debug tests/code when needed.  The Rust
ecosystem is very rich and active and people with other needs have contributed with really useful tools.</p>
<p>
Today, I will write about two tools that might come in handy for you sooner or latter.  There are many details in the
following paragraphs, so fasten your USB-C cable and get ready!</p>]]></description>
</item>
<item>
    <title>Rust unit testing: builtin tools</title>
    <link>https://jorgeortiz.dev/posts/rust_unit_testing_tools_builtin/</link>
    <pubDate>Mon, 22 Sep 2025 00:00:00 &#43;0000</pubDate>
    <author>Jorge Ortiz-Fuentes</author>
    <guid>https://jorgeortiz.dev/posts/rust_unit_testing_tools_builtin/</guid>
    <description><![CDATA[<div class="featured-image">
                <img src="/header-image.jpg" referrerpolicy="no-referrer">
            </div><p>
As many other modern languages, regarding testing, Rust comes with batteries included.  As you have seen in the previous
articles of this series, you don&#39;t need to take any extra steps to be able to write and run unit tests for your code.
It is clear where you have to put them, how to run them, and even cargo has a subcommand for finding and running
them, and reporting the results.  Could we ask for more?</p>]]></description>
</item>
</channel>
</rss>
